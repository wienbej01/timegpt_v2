"""Tests for payload builder with allow-lists and strict exogenous validation."""

from __future__ import annotations

import pandas as pd
import pytest

from timegpt_v2.framing.build_payloads import (
    FUTR_EXOG_ALLOW,
    HIST_EXOG_ALLOW,
    build_x_df_for_horizon,
    build_y_df,
)


@pytest.fixture
def sample_features() -> pd.DataFrame:
    """Create sample feature data with both historical and deterministic features."""
    timestamps = pd.date_range("2024-07-01 09:30:00", periods=100, freq="1min", tz="UTC")

    data = pd.DataFrame({
        "timestamp": timestamps,
        "symbol": "AAPL",
        "target_log_return_1m": [0.001] * 100,
        # Historical exogenous features (HIST_EXOG_ALLOW)
        "ret_1m": [0.001] * 100,
        "ret_5m": [0.005] * 100,
        "sigma_5m": [0.02] * 100,
        "parkinson_sigma_15m": [0.025] * 100,
        "range_pct_15m": [0.01] * 100,
        "clv_15m": [0.5] * 100,
        "vwap_dev": [0.001] * 100,
        "rth_cumret_30m": [0.015] * 100,
        "spy_ret_1m": [0.0005] * 100,
        "spy_vol_30m": [0.015] * 100,
        "regime_high_vol": [0] * 100,
        "regime_high_dispersion": [0] * 100,
        # Deterministic features (FUTR_EXOG_ALLOW) - will be generated by deterministic.py
        "fourier_sin_1": [0.1] * 100,
        "fourier_cos_1": [0.9] * 100,
        "day_of_week": [0] * 100,  # Monday
        "minutes_since_open": list(range(100)),
        "minutes_to_close": [390 - i for i in range(100)],
        # Additional features that should NOT be included (not in allow-lists)
        "ret_15m": [0.015] * 100,  # Not in HIST_EXOG_ALLOW
        "sigma_15m": [0.03] * 100,  # Not in HIST_EXOG_ALLOW
        "fourier_sin_2": [0.2] * 100,  # Not in FUTR_EXOG_ALLOW
    })

    return data


def test_y_df_includes_only_allowed_features(sample_features: pd.DataFrame) -> None:
    """Test that y_df includes only HIST_EXOG_ALLOW + FUTR_EXOG_ALLOW features."""
    snapshot_ts = pd.Timestamp("2024-07-01 10:00:00", tz="UTC")

    y_df = build_y_df(
        sample_features,
        snapshot_ts,
        target_column="target_log_return_1m",
        rolling_window_days=1,
        min_obs_subhourly=1,
        symbols=["AAPL"]
    )

    # Check that base columns exist
    assert "unique_id" in y_df.columns, "unique_id column missing"
    assert "ds" in y_df.columns, "ds column missing"
    assert "y" in y_df.columns, "y column missing"

    # Check that only allowed historical features are included
    hist_features_included = [col for col in HIST_EXOG_ALLOW if col in y_df.columns]
    hist_features_excluded = [col for col in HIST_EXOG_ALLOW if col not in y_df.columns]

    # All available historical features should be included
    for feature in hist_features_included:
        assert y_df[feature].notna().any(), f"Historical feature {feature} should have non-NaN values"

    # Check that only allowed deterministic features are included
    det_features_included = [col for col in FUTR_EXOG_ALLOW if col in y_df.columns]
    for feature in det_features_included:
        assert y_df[feature].notna().any(), f"Deterministic feature {feature} should have non-NaN values"

    # Check that non-allowed features are NOT included
    forbidden_features = ["ret_15m", "sigma_15m", "fourier_sin_2"]
    for feature in forbidden_features:
        assert feature not in y_df.columns, f"Non-allowed feature {feature} should not be in y_df"

    # Verify column count is reasonable
    total_allowed = len(HIST_EXOG_ALLOW) + len(FUTR_EXOG_ALLOW)
    actual_exog_count = len(y_df.columns) - 3  # Subtract unique_id, ds, y
    assert actual_exog_count <= total_allowed, f"Too many exogenous columns: {actual_exog_count} > {total_allowed}"


def test_x_df_includes_only_deterministic_features(sample_features: pd.DataFrame) -> None:
    """Test that x_df includes only FUTR_EXOG_ALLOW features."""
    snapshot_ts = pd.Timestamp("2024-07-01 10:00:00", tz="UTC")
    horizon_minutes = 5

    x_df = build_x_df_for_horizon(
        sample_features,
        snapshot_ts,
        horizon_minutes,
        symbols=["AAPL"],
        strict_exog=False,
    )

    # Check that base columns exist
    assert "unique_id" in x_df.columns, "unique_id column missing"
    assert "ds" in x_df.columns, "ds column missing"

    # Check that only deterministic features are included
    det_features_included = [col for col in FUTR_EXOG_ALLOW if col in x_df.columns]
    for feature in det_features_included:
        assert x_df[feature].notna().all(), f"Deterministic feature {feature} should have no NaNs"

    # Check that historical features are NOT included
    historical_forbidden = HIST_EXOG_ALLOW + ["ret_15m", "sigma_15m"]
    for feature in historical_forbidden:
        assert feature not in x_df.columns, f"Historical feature {feature} should not be in x_df"

    # Verify column count
    expected_cols = 2 + len(det_features_included)  # unique_id, ds + deterministic features
    assert len(x_df.columns) == expected_cols, f"Unexpected column count: {len(x_df.columns)} != {expected_cols}"


def test_strict_exog_passes_with_all_features(sample_features: pd.DataFrame) -> None:
    """Test that strict_exog=True passes when all FUTR_EXOG_ALLOW features are present."""
    snapshot_ts = pd.Timestamp("2024-07-01 10:00:00", tz="UTC")
    horizon_minutes = 3

    # Should not raise an error when all deterministic features are present
    x_df = build_x_df_for_horizon(
        sample_features,
        snapshot_ts,
        horizon_minutes,
        symbols=["AAPL"],
        strict_exog=True,
    )

    # Should include all deterministic features
    for feature in FUTR_EXOG_ALLOW:
        assert feature in x_df.columns, f"Deterministic feature {feature} should be present with strict_exog=True"

    assert len(x_df) == horizon_minutes, f"Should have {horizon_minutes} rows"


def test_strict_exog_fails_with_missing_features() -> None:
    """Test that strict_exog=True fails when FUTR_EXOG_ALLOW features are missing.

    Note: deterministic.add_time_features() always generates all FUTR_EXOG_ALLOW features,
    so this test creates a scenario where the function doesn't have access to some features.
    """
    # Test with a mock deterministic function that doesn't generate all features
    from timegpt_v2.framing import build_payloads
    import unittest.mock

    snapshot_ts = pd.Timestamp("2024-07-01 10:00:00", tz="UTC")
    horizon_minutes = 3

    # Mock deterministic.add_time_features to return incomplete features
    def mock_add_time_features(df):
        # Only return some deterministic features
        result = df.copy()
        result["fourier_sin_1"] = 0.1
        result["fourier_cos_1"] = 0.9
        # Missing: minutes_since_open, minutes_to_close, day_of_week
        result["unique_id"] = result["symbol"]
        return result

    minimal_data = pd.DataFrame({
        "timestamp": [pd.Timestamp("2024-07-01 10:00:00", tz="UTC")],
        "symbol": "AAPL",
        "target_log_return_1m": [0.001],
    })

    with unittest.mock.patch.object(build_payloads.deterministic, 'add_time_features', side_effect=mock_add_time_features):
        # Should raise an error when deterministic features are missing and strict_exog=True
        with pytest.raises(ValueError, match="strict_exog=True: missing deterministic exogenous features"):
            build_x_df_for_horizon(
                minimal_data,
                snapshot_ts,
                horizon_minutes,
                symbols=["AAPL"],
                strict_exog=True,
            )


def test_strict_exog_false_ignores_missing_features() -> None:
    """Test that strict_exog=False works when deterministic features are available.

    Note: deterministic.add_time_features() always generates all FUTR_EXOG_ALLOW features,
    so x_df will always contain deterministic features when strict_exog=False.
    """
    # Create minimal data
    minimal_data = pd.DataFrame({
        "timestamp": [pd.Timestamp("2024-07-01 10:00:00", tz="UTC")],
        "symbol": "AAPL",
        "target_log_return_1m": [0.001],
    })

    snapshot_ts = pd.Timestamp("2024-07-01 10:00:00", tz="UTC")
    horizon_minutes = 3

    # Should not raise an error when strict_exog=False
    x_df = build_x_df_for_horizon(
        minimal_data,
        snapshot_ts,
        horizon_minutes,
        symbols=["AAPL"],
        strict_exog=False,
    )

    # Should have base columns plus deterministic features (since they're always generated)
    assert "unique_id" in x_df.columns, "unique_id column missing"
    assert "ds" in x_df.columns, "ds column missing"

    # Should include all deterministic features
    for feature in FUTR_EXOG_ALLOW:
        assert feature in x_df.columns, f"Deterministic feature {feature} should be present"

    # Should not include any historical features
    for feature in HIST_EXOG_ALLOW:
        assert feature not in x_df.columns, f"Historical feature {feature} should not be in x_df"


def test_payload_logging_with_allow_lists(sample_features: pd.DataFrame, monkeypatch) -> None:
    """Test that payload logging includes allow-list information."""
    import os
    import logging

    # Enable payload logging
    monkeypatch.setenv("PAYLOAD_LOG", "1")

    # Capture logs
    logger = logging.getLogger("timegpt_v2.build_payloads")

    # Create a handler to capture log messages
    import io
    log_capture = io.StringIO()
    handler = logging.StreamHandler(log_capture)
    logger.addHandler(handler)
    logger.setLevel(logging.INFO)

    try:
        snapshot_ts = pd.Timestamp("2024-07-01 10:00:00", tz="UTC")

        # Build y_df to trigger payload logging
        y_df = build_y_df(
            sample_features,
            snapshot_ts,
            target_column="target_log_return_1m",
            rolling_window_days=1,
            min_obs_subhourly=1,
            symbols=["AAPL"]
        )

        # Build x_df to trigger payload logging
        x_df = build_x_df_for_horizon(
            sample_features,
            snapshot_ts,
            horizon_minutes=5,
            symbols=["AAPL"],
            strict_exog=False,
        )

        # Check that log contains allow-list information
        log_output = log_capture.getvalue()
        assert "PAYLOAD y_df cols=" in log_output, "Payload logging should trigger for y_df"
        assert "hist_exog=" in log_output, "Payload log should include hist_exog count"
        assert "det_exog=" in log_output, "Payload log should include det_exog count"
        assert "PAYLOAD x_df cols=" in log_output, "Payload logging should trigger for x_df"
        assert "strict_exog=" in log_output, "Payload log should include strict_exog status"

    finally:
        logger.removeHandler(handler)


def test_allow_list_coverage() -> None:
    """Test that allow-lists cover expected feature categories."""
    # HIST_EXOG_ALLOW should contain OHLCV features from Sprint 1
    ohlcv_features = {
        "ret_1m", "ret_5m",  # Returns
        "sigma_5m",  # Realized volatility
        "parkinson_sigma_15m",  # Parkinson volatility
        "range_pct_15m", "clv_15m",  # Range-based features
        "vwap_dev",  # VWAP deviation
        "rth_cumret_30m",  # Cumulative return
    }

    assert set(HIST_EXOG_ALLOW) >= ohlcv_features, "HIST_EXOG_ALLOW should contain all OHLCV features"

    # FUTR_EXOG_ALLOW should contain deterministic time features
    deterministic_features = {
        "fourier_sin_1", "fourier_cos_1",  # Fourier components
        "minutes_since_open", "minutes_to_close",  # Session clock
        "day_of_week",  # Calendar feature
    }

    assert set(FUTR_EXOG_ALLOW) == deterministic_features, "FUTR_EXOG_ALLOW should match deterministic features"

    # Allow-lists should not overlap
    overlap = set(HIST_EXOG_ALLOW) & set(FUTR_EXOG_ALLOW)
    assert not overlap, f"HIST_EXOG_ALLOW and FUTR_EXOG_ALLOW should not overlap: {overlap}"


def test_empty_features_handling() -> None:
    """Test that empty feature dataframes are handled gracefully."""
    empty_features = pd.DataFrame(columns=["timestamp", "symbol", "target_log_return_1m"])
    snapshot_ts = pd.Timestamp("2024-07-01 10:00:00", tz="UTC")

    # y_df should return empty DataFrame with correct columns
    y_df = build_y_df(
        empty_features,
        snapshot_ts,
        target_column="target_log_return_1m",
        symbols=["AAPL"]
    )

    assert y_df.empty, "y_df should be empty for empty input"
    assert list(y_df.columns) == ["unique_id", "ds", "y"], "y_df should have correct columns for empty input"

    # x_df generates deterministic features even from empty input, so it won't be empty
    # But it should handle the case gracefully by only generating deterministic features
    x_df = build_x_df_for_horizon(
        empty_features,
        snapshot_ts,
        horizon_minutes=5,
        symbols=["AAPL"]
    )

    # Should not be empty since deterministic features are generated
    assert not x_df.empty, "x_df should not be empty as deterministic features are generated"
    assert len(x_df) == 5, f"Should have {5} rows for horizon of 5 minutes"

    # Should have base columns and deterministic features
    assert "unique_id" in x_df.columns, "unique_id column missing"
    assert "ds" in x_df.columns, "ds column missing"

    # Should include all deterministic features
    for feature in FUTR_EXOG_ALLOW:
        assert feature in x_df.columns, f"Deterministic feature {feature} should be present"

    # Should not include any historical features
    for feature in HIST_EXOG_ALLOW:
        assert feature not in x_df.columns, f"Historical feature {feature} should not be in x_df"


if __name__ == "__main__":
    pytest.main([__file__])