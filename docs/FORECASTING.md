# Forecasting Foundations

## Feature Policy & Leakage

The intraday feature stack is anchored on return-space targets to avoid scale drift and to keep the prediction target stationary. Minute close-to-close log returns define the default label (`target_log_return_1m`), while predictor columns are strictly sourced from information available at or before the feature timestamp. Rolling windows never peek forward: momentum (`ret_1m/5m/15m`), realised variance (`rv_5m/15m`), ATR, and Parkinson / Garman–Klass volatility are all computed with past bars only. Volume-sensitive signals (`VWAP_30m`, `z_close_vwap_30m`, `vol_5m_norm`) normalise intraday liquidity by recent history, ensuring each row represents the state just prior to the forecast horizon. Deterministic components expose an explicit `minute_index`, Fourier harmonics, and session buckets—fully reproducible from the timestamp and trading calendar—while contextual enrichments keep SPY factors lagged by one minute and layer on regime flags and event dummies (earnings/FOMC/CPI). After the feature pass we drop any row where the NaN share exceeds 1%, guaranteeing downstream models see leakage-safe and numerically stable matrices stored under `artifacts/runs/<run_id>/features/`.

## Quantiles & Batching

Sprint 3 wires the framing layer directly into the TimeGPT client. For each trading day and configured ET snapshot we build a leakage-safe target frame (`unique_id, ds, y`) and project the deterministic feature block forward minute-by-minute to the forecast horizon. The client batches all series in one call with `freq="min"`, requesting `[0.25, 0.5, 0.75]` quantiles and defaulting to a 15-minute horizon (configurable via `configs/forecast.yaml`). Results are cached per `(symbol, trade_date, snapshot, horizon, quantiles)` so re-forecasts hit disk-backed storage when possible, logging cache hits to keep runs auditable. Aggregated quantiles flow into `artifacts/runs/<run_id>/forecasts/quantiles.csv`—one row per symbol, stamped in UTC—ensuring downstream evaluation receives consistent multi-series forecasts without duplicate API calls.

## Snapshot policy

The forecasting pipeline is driven by a scheduler that generates a series of snapshot timestamps for each trading day. The scheduler is configured in `configs/forecast.yaml` and can be customized to specify the snapshot times, the time zone, and the trading holidays.

The scheduler skips weekends and holidays, and only generates snapshots for the specified times on trading days. `configs/forecast.yaml` now exposes `active_windows` to bound intraday activity (e.g., avoid the open auction or late-day liquidity cliffs) and `max_snapshots_per_day`/`max_snapshots_total` guardrails to cap how many requests fire in a session. Within each snapshot, the CLI chunks symbols by `max_batch_size` to stay under per-call limits while still covering the full universe deterministically. This keeps forecasts aligned to market windows and API quotas without manual intervention.
